<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <title>Three练手</title>
    <script src="Tween.js"></script>
</head>
<style>
    body {
        margin: 0;
        position: relative;
    }

    canvas {
        width: 100%;
        height: 100%;
        vertical-align: top;
    }

    #fullScreen {
        position: absolute;
        width: 50px;
        height: 50px;
        background: #000;
        bottom: 20px;
        right: 20px;
        z-index: 10000;
        display: none;
    }

    #exitFullScreen {
        position: absolute;
        width: 50px;
        height: 50px;
        background: pink;
        bottom: 20px;
        right: 20px;
        z-index: 10000;
        display: none;
    }
</style>
<body>
<div id="fullScreen"></div>
<div id="exitFullScreen"></div>
<script type="text/javascript" src="tree.min.js"></script>
<script type="text/javascript" src="dat.gui.js"></script>
<script type="text/javascript" src="Stats.js"></script>
<script type="text/javascript" src="Tween.js"></script>
<script type="text/javascript" src="text.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script>
    if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
        $("#fullScreen").hide();
        $("#exitFullScreen").hide();

    } else {
        $("#fullScreen").show();
    }


    //fullScreen()和exitScreen()有多种实现方式，此处只使用了其中一种
    //全屏
    function fullScreen() {
        var element = document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        }
    }

    //退出全屏
    function exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    }

    $("#fullScreen").on("click", function () {
        fullScreen();
    });
    //退出全屏
    $("#exitFullScreen").on("click", function () {
        exitFullscreen();
    });


    let scene, camera, light, sphere, renderer, stats, test, flag;
    let width = window.innerWidth,
        height = window.innerHeight;
    let camera_time = 0;
    flag = 0;
    // 计算出鼠标经过的3d空间中的对象
    // Raycaster( origin, direction, near, far ) { }
    // origin — 射线的起点向量。
    // direction — 射线的方向向量，应该归一化。
    // near — 所有返回的结果应该比 near 远。Near不能为负，默认值为0。
    // far — 所有返回的结果应该比 far 近。Far 不能小于 near，默认值为无穷大。
    let raycaster = new THREE.Raycaster(); // 对象从屏幕上的点击位置向场景中发射一束光线。
    var mouse = new THREE.Vector2(); //将鼠标位置
    /**
     *   初始化 场景
     **/
    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog('#fff', 0.3, 5600);
        scene.autoUpdate = true;
    }

    /**
     *   初始化 照相机
     **/
    function initCamera() {
        camera = new THREE.PerspectiveCamera(75, width / height, 1, 1600);
        camera.target = new THREE.Vector3(0, 0, 0);
        /**
         *  camera.position：相机所在的位置，默认为（0，0，0）
         *  camera.lookAt：相机焦点方向，默认为Z轴负半轴方向
         *  camera.up：坐标轴向上方向，默认（0，1，0）。PS：要设置在camera.lookAt前才有效
         **/
        // camera.position.y = 560;
        // camera.position.z = 0;
        // camera.up.x = 0;
        // camera.up.y = 0;
        // camera.up.z = 0;
        // camera.lookAt(500, 500, 1);
    }

    /**
     *   初始化 光源
     **/
    function initLight() {
        /**
         *  平行光源
         *  DirectionalLight( hex, intensity )
         *  hex -- 光源颜色的RGB数值。
         *  intensity -- 光源强度的数值。
         **/
        light = new THREE.DirectionalLight(0xff0000);
        light.position.set(100, 100, 200);
        scene.add(light);

        light = new THREE.PointLight(0x00FF00);
        light.position.set(0, 0, 300);
        scene.add(light);
    }

    /**
     *   初始化 几何体
     *   创建一个球体网格，对网格进行x轴反转，使所有的面点向内
     **/
    let geometry, material;

    function initBall() {
        // 辅助线
        // var object = new THREE.AxesHelper(500);
        // scene.add(object);
        geometry = new THREE.SphereBufferGeometry(500, 500, 500);
        geometry.scale(-1, 1, 1);
        material = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('3.jpg'), //加载第一张图片
            depthTest: false //此参数控制是否使用像素深度来计算新像素的值
        });
        test = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('1.jpg'), //加载第二张图片 待替换
            depthTest: false //此参数控制是否使用像素深度来计算新像素的值
        });
        sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
    }

    /**
     *   初始化 渲染器
     **/
    function initRender() {
        renderer = new THREE.WebGLRenderer({
            // antialias: true // 开启抗锯齿
        });
        renderer.setSize(width, height);
        renderer.setClearColor(0xeeeeee, .08); // 设置清除的颜色和透明度
        document.body.appendChild(renderer.domElement);
        /**
         *   初始化 调试器
         **/
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild(stats.domElement);
    }

    /**
     *   动画效果
     **/
    function initTween() {
        // new TWEEN.Tween(camera.position)
        //     .to({y: 0}, 2000).start();
    }

    /**
     *   render动画
     **/
    function render() {
        animate.autoRotate = controls.autoRotate;
        animate.autoRotateSpeed = controls.autoRotateSpeed;
        move();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        animate.update();
        stats.update();
        // TWEEN.update();
    }

    /**
     *   gui控制器
     **/
    let controls = new function () {
        this.speed = 0.001;
        this.fov = 45;
        this.autoRotate = false;
        this.autoRotateSpeed = 0.1;
    };
    const gui = new dat.GUI();

    // gui.add(controls, 'speed', 0, 0.5).name('旋转速度');
    // gui.add(controls, 'fov', 45, 75).name('视角大小');
    gui.add(controls, 'autoRotate', true, false).name('自动旋转');
    gui.add(controls, 'autoRotateSpeed', 0, 0.5).name('旋转速度');

    function setCameraFov(fov) {
        camera.fov = fov;
        camera.updateProjectionMatrix();
    }

    function changeFov() {
        setCameraFov(controls.fov);
    }

    /**
     *   初始化 精灵
     **/
    let sprite;

    function initSprite() {
        var geometry = new THREE.PlaneGeometry(100, 50);
        var texture = new THREE.TextureLoader().load("123.gif");
        var material = new THREE.MeshBasicMaterial({map: texture});
        sprite = new THREE.Mesh(geometry, material);
        sprite.position.set(-40, -100.5, -200.5);
        scene.add(sprite);

        // let spriteOrigin = makeTextSprite( "阿七测试点击啊啊啊啊");
        // console.log(spriteOrigin);
        // spriteOrigin.center = new THREE.Vector2(0, 0);
        // scene.add( spriteOrigin );
        // spriteOrigin.scale.set(1, 1, 1);
        // spriteOrigin.position.set(-40, -100.5, -200.5);
        // return spriteOrigin;
    }

    let sprite1;

    function initSprite1() {
        var geometry1 = new THREE.PlaneGeometry(100, 100);
        var texture1 = new THREE.TextureLoader().load("44.jpg");
        var material1 = new THREE.MeshBasicMaterial({map: texture1});
        sprite1 = new THREE.Mesh(geometry1, material1);
        sprite1.position.set(40, -100.5, -200.5);
        sprite1.rotation.y = 45;
        sprite1.visible = false;
        scene.add(sprite1);
    }

    /**
     *   鼠标点击事件
     **/
    function onMouseMove(event) {
        event.preventDefault();
        // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);   //射线捕捉
        var intersects = raycaster.intersectObject(sprite, true);
        if (intersects.length > 0) {
            flag = 1;
            camera_time = 1;
            move();
        }

        var intersects1 = raycaster.intersectObject(sprite1, true);
        if (intersects1.length > 0) {
            flag = 2;
            camera_time = 1;
            move();
        }

    }

    function move() {
        if (flag === 1) {
            if (camera_time > 0 && camera_time < 50) {
                camera.fov -= 1;
                camera.updateProjectionMatrix();	//需要更新，不自动更新
                camera_time++;
                sprite.visible = false;
            } else if (camera_time === 50) {
                camera_time = 0;
                camera.fov = 75;
                camera.updateProjectionMatrix();
                sphere.material = test;
                sprite1.visible = true;
            }
        } else if (flag === 2) {
            if (camera_time > 0 && camera_time < 50) {
                camera.fov -= 1;
                camera.updateProjectionMatrix();	//需要更新，不自动更新
                camera_time++;
                sprite1.visible = false
            } else if (camera_time === 50) {
                camera_time = 0;
                camera.fov = 75;
                camera.updateProjectionMatrix();
                sphere.material = material;
                sprite.visible = true;
            }
        }

    }

    /**
     *   移动端点击事件
     **/
    function onDocumentTouchDown(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);   //射线捕捉
        var intersects = raycaster.intersectObject(sprite, true);
        if (intersects.length > 0) {
            camera_time = 1;
            move();
        }
        var intersects1 = raycaster.intersectObject(sprite1, true);
        if (intersects1.length > 0) {
            camera_time = 1;
            move();
        }
    }

    window.addEventListener('mousedown', onMouseMove, false);
    window.addEventListener('touchstart', onDocumentTouchDown, false);

    /**
     *   窗口变动触发的函数
     **/
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize(window.innerWidth, window.innerHeight);


        var isFull = !!(document.webkitIsFullScreen || document.mozFullScreen ||
            document.msFullscreenElement || document.fullscreenElement
        );//!document.webkitIsFullScreen都为true。因此用!!
        if (isFull === false) {
            $("#exitFullScreen").hide();
            $("#fullScreen").show();
        } else {
            $("#exitFullScreen").show();
            $("#fullScreen").hide();
        }
    }


    /**
     *   轨道控制
     **/
    let animate;

    function initAnimate() {
        animate = new THREE.OrbitControls(camera, renderer.domElement);
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        animate.enableDamping = true;
        animate.dampingFactor = 0.34;
        //是否可以缩放
        animate.enableZoom = true;
        //是否自动旋转
        // animate.autoRotate = controls.autoRotate;
        // animate.autoRotateSpeed = controls.autoRotateSpeed;
        //设置相机距离原点的最远距离
        animate.minDistance = 80;
        //设置相机距离原点的最远距离
        animate.maxDistance = 240;
        //是否开启右键拖拽
        animate.enablePan = false;
    }

    const Start = () => {
        initRender();
        initCamera();
        initScene();
        initLight();
        initBall();
        initTween();
        initSprite();
        initSprite1();
        initAnimate();
        renderer.clear();
        render();
        window.onresize = onWindowResize;
    };
    Start();
</script>
</body>
</html>
