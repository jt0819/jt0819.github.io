<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <title>Threeç»ƒæ‰‹</title>
    <script src="Tween.js"></script>
</head>
<style>
    body {
        margin: 0;
    }

    canvas {
        width: 100%;
        height: 100%;
        vertical-align: top;
    }
</style>
<body>
<script type="text/javascript" src="tree.min.js"></script>
<script type="text/javascript" src="dat.gui.js"></script>
<script type="text/javascript" src="Stats.js"></script>
<script type="text/javascript" src="Tween.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>

<script>
    let scene, camera, light, cube, renderer, stats;
    let width = window.innerWidth,
        height = window.innerHeight;
    // è®¡ç®—å‡ºé¼ æ ‡ç»è¿‡çš„3dç©ºé—´ä¸­çš„å¯¹è±¡
    // Raycaster( origin, direction, near, far ) { }
    // origin â€” å°„çº¿çš„èµ·ç‚¹å‘é‡ã€‚
    // direction â€” å°„çº¿çš„æ–¹å‘å‘é‡ï¼Œåº”è¯¥å½’ä¸€åŒ–ã€‚
    // near â€” æ‰€æœ‰è¿”å›çš„ç»“æœåº”è¯¥æ¯” near è¿œã€‚Nearä¸èƒ½ä¸ºè´Ÿï¼Œé»˜è®¤å€¼ä¸º0ã€‚
    // far â€” æ‰€æœ‰è¿”å›çš„ç»“æœåº”è¯¥æ¯” far è¿‘ã€‚Far ä¸èƒ½å°äº nearï¼Œé»˜è®¤å€¼ä¸ºæ— ç©·å¤§ã€‚
    let raycaster = new THREE.Raycaster(); // å¯¹è±¡ä»å±å¹•ä¸Šçš„ç‚¹å‡»ä½ç½®å‘åœºæ™¯ä¸­å‘å°„ä¸€æŸå…‰çº¿ã€‚
    var mouse = new THREE.Vector2(); //å°†é¼ æ ‡ä½ç½®
    // åˆå§‹åŒ– åœºæ™¯
    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog('#f60', 0.3, 2500);
        scene.autoUpdate = true;
    }

    // åˆå§‹åŒ– ç…§ç›¸æœº
    function initCamera() {
        camera = new THREE.PerspectiveCamera(75, width / height, 1, 5500);
        /**
         *  camera.positionï¼šç›¸æœºæ‰€åœ¨çš„ä½ç½®ï¼Œé»˜è®¤ä¸ºï¼ˆ0ï¼Œ0ï¼Œ0ï¼‰
         *  camera.lookAtï¼šç›¸æœºç„¦ç‚¹æ–¹å‘ï¼Œé»˜è®¤ä¸ºZè½´è´ŸåŠè½´æ–¹å‘
         *  camera.upï¼šåæ ‡è½´å‘ä¸Šæ–¹å‘ï¼Œé»˜è®¤ï¼ˆ0ï¼Œ1ï¼Œ0ï¼‰ã€‚PSï¼šè¦è®¾ç½®åœ¨camera.lookAtå‰æ‰æœ‰æ•ˆ
         **/
        // camera.position.x = 0;
        // camera.position.y = 0;
        // camera.position.z = 0;
        // camera.up.x = 0;
        // camera.up.y = 0;
        // camera.up.z = 0;
        // camera.lookAt(0, 10, 0);
        camera.target = new THREE.Vector3(0, 0, 0);

    }

    // åˆå§‹åŒ– å…‰æº
    function initLight() {
        /**
         *  å¹³è¡Œå…‰æº
         *  DirectionalLight( hex, intensity )
         *  hex -- å…‰æºé¢œè‰²çš„RGBæ•°å€¼ã€‚
         *  intensity -- å…‰æºå¼ºåº¦çš„æ•°å€¼ã€‚
         **/
        light = new THREE.DirectionalLight(0xff0000);
        light.position.set(100, 100, 200);
        scene.add(light);

        light = new THREE.PointLight(0x00FF00);
        light.position.set(0, 0, 300);
        scene.add(light);
    }

    // åˆå§‹åŒ– å‡ ä½•ä½“
    let sphere;
    const initBall = () => {
        // var object = new THREE.AxesHelper(500);
        // scene.add(object);
        var geometry = new THREE.SphereBufferGeometry(500, 500, 500);
        geometry.scale(-1, 1, 1);
        var material = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('3.jpg') //åŠ è½½ä¸€æ•´å¼ çº¹ç†å›¾ç‰‡
        });
        sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
    }
    const initGeometry = () => {
        var geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3(-500, 0, 0),
            new THREE.Vector3(500, 0, 0)
        );
        for (let i = 0; i <= 20; i++) {

            var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xffec3d, opacity: 0.2}));
            line.position.y = (i * 50) - 500;
            scene.add(line);

            cube = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xf5222d, opacity: 0.2}));
            cube.position.x = (i * 50) - 500;
            cube.rotation.z = 90 * Math.PI / 180;
            scene.add(cube);
        }
    };
    const initXLine = () => {
        var geometry = new THREE.Geometry();
        var a = new THREE.Vector3(-100, 0, 0), b = new THREE.Vector3(100, 0, 0);
        var color_a = new THREE.Color(0xf60), color_b = new THREE.Color(0x0085d0);
        geometry.vertices.push(
            a,
            b
        );
        geometry.colors.push(
            color_a,
            color_b
        );
        var material = new THREE.LineBasicMaterial({vertexColors: true});
        var line = new THREE.Line(geometry, material);
        scene.add(line);
    };
    const initYLine = () => {
        var geometry = new THREE.Geometry();
        var a = new THREE.Vector3(0, 0, -100), b = new THREE.Vector3(0, 0, 100);
        var color_a = new THREE.Color(0xfa541c), color_b = new THREE.Color(0xa0d911);
        geometry.vertices.push(
            a,
            b
        );
        geometry.colors.push(
            color_a,
            color_b
        );
        var material = new THREE.LineBasicMaterial({vertexColors: true});
        var line = new THREE.Line(geometry, material);
        scene.add(line);
    };
    const initZLine = () => {
        var geometry = new THREE.Geometry();
        var a = new THREE.Vector3(0, -100, 0), b = new THREE.Vector3(0, 100, 0);
        var color_a = new THREE.Color(0xeb2f96), color_b = new THREE.Color(0x2f54eb);
        geometry.vertices.push(
            a,
            b
        );
        geometry.colors.push(
            color_a,
            color_b
        );
        var material = new THREE.LineBasicMaterial({vertexColors: true});
        var line = new THREE.Line(geometry, material);
        scene.add(line);
    };
    // åˆå§‹åŒ– æ¸²æŸ“å™¨
    const initRender = () => {
        renderer = new THREE.WebGLRenderer({
            antialias: true // å¼€å¯æŠ—é”¯é½¿
        });
        renderer.setSize(width, height);
        renderer.setClearColor(0xeeeeee, .08); // è®¾ç½®æ¸…é™¤çš„é¢œè‰²å’Œé€æ˜åº¦
        document.body.appendChild(renderer.domElement);

        // è°ƒè¯•å™¨
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild(stats.domElement);
    };

    function initTween() {
        new TWEEN.Tween(sphere.position)
            .to({z: 666}, 5000)
            .repeat(Infinity).start();
    }

    // åŠ¨ç”»
    const render = function () {
        animate.update();
        requestAnimationFrame(render);
        // cube.rotation.z += 0.05;
        // cube.rotation.y += 0.01;
        // camera.position.x += 1;
        // camera.position.z += 0.1;
        // camera.position.z += 0.1;
        // camera.position.x += 0.2;
        // console.log(controls.fov);
        // camera.fov += controls.fov;
        // changeFov();
        // sphere.rotation.z += controls.speed;
        // sphere.rotation.y += controls.speed;
        // sphere.rotation.z += controls.speed;
        renderer.render(scene, camera);
        stats.update();
        // TWEEN.update();
    };

    let controls = new function () {
        this.speed = 0.001;
        this.fov = 45;
    };
    const gui = new dat.GUI();

    // gui.add(controls, 'speed', 0, 0.5).name('æ—‹è½¬é€Ÿåº¦');
    // gui.add(controls, 'fov', 45, 75).name('è§†è§’å¤§å°');

    function setCameraFov(fov) {
        camera.fov = fov;
        camera.updateProjectionMatrix();
    }

    function changeFov() {
        setCameraFov(controls.fov);
    }

    function initSprite() {
        var spriteMap = new THREE.TextureLoader().load('21.png');

        var spriteMaterial = new THREE.SpriteMaterial({
            map: spriteMap,
            color: 0xffffff,
            useScreenCoordinates: false,
            sizeAttenuation: false
        });

        var sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(0.05, 0.05, 0.05);
        sprite.position.set(-20, -200.5, -200.5);

        scene.add(sprite);

        // sprite.visible = false
    }

    //çª—å£å˜åŠ¨è§¦å‘çš„å‡½æ•°
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    let animate;

    function initAnimate() {
        animate = new THREE.OrbitControls(camera, renderer.domElement);
        //åŠ¨æ€é˜»å°¼ç³»æ•° å°±æ˜¯é¼ æ ‡æ‹–æ‹½æ—‹è½¬çµæ•åº¦
        animate.dampingFactor = 1.8;
        //æ˜¯å¦å¯ä»¥ç¼©æ”¾
        animate.enableZoom = true;
        //æ˜¯å¦è‡ªåŠ¨æ—‹è½¬
        animate.autoRotate = true;
        animate.autoRotateSpeed = 0.1;
        //è®¾ç½®ç›¸æœºè·ç¦»åŸç‚¹çš„æœ€è¿œè·ç¦»
        animate.minDistance = 10;
        //è®¾ç½®ç›¸æœºè·ç¦»åŸç‚¹çš„æœ€è¿œè·ç¦»
        animate.maxDistance = 1000;
        //æ˜¯å¦å¼€å¯å³é”®æ‹–æ‹½
        animate.enablePan = false;
    }


    const Start = () => {
        initRender();
        initCamera();
        initScene();
        initLight();
        // initXLine();
        // initYLine();
        // initZLine();
        // initGeometry();
        initBall();
        // initTween();
        initSprite();
        initAnimate();
        renderer.clear();
        render();
        window.onresize = onWindowResize;
    };
    Start()
    // <div class="box">â¤â¤â¤â¤â¤â¤</div>
    // <div class="box">ğŸ’”ğŸ’”ğŸ’”ğŸ’”ğŸ’”ğŸ’”</div>
</script>
</body>
</html>
